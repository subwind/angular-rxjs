<h2>Observable</h2>
<pre>
   <!-- <code class="jsType">
     <span class="jsKey">const</span> observable = <span class="jsKey">new</span> <span class="jsFunc">
       
     </span>
  </code> -->
   1.const observable = new Observable()
   2.const observable2 = of('Observables use of 1','Observables use of 2');

   P.S. Observable.create() and new Observable() essentially do the same thing.
</pre>
<div id="observable"></div>

<h2>Subject</h2>
<pre>
  const subject = new Subject();
  subject.next('missed message from Subject');
  subject.subscribe();
  subject.next('hello from subject!');
</pre>
<div id="subject"></div>

<h3>ReplaySubject</h3>
<div>會記錄所有呼叫 next() 變更的資料，在被 subscribe() 時，重新播放所有紀錄(可設定紀錄最近的 N 筆)</div>
<pre>
  const replaySubject = new ReplaySubject();
  replaySubject.next('hello from ReplaySubject!');
  replaySubject.next('hello from second event from ReplaySubject!');
  replaySubject.subscribe();
</pre>
<div id="replaySubject"></div>

<h3>BehaviorSubject</h3>
<div>可以在資料被訂閱前，給予初始資料，任何 next 發生前執行 subscribe()都會得到初始資料</div>
<pre>
  const behaviorSubject = new BehaviorSubject('hello initial value from BehaviorSubject');
  behaviorSubject.subscribe();
  behaviorSubject.next('hello again from BehaviorSubject');
</pre>
<pre></pre>
<div id="behaviorSubject"></div>

<h3>AsyncSubject</h3>
<div>他只有在 complete() 方法被呼叫時，才能訂閱到「最後一次 next() 的資料」</div>
<pre>
  const asyncSubject = new AsyncSubject();
  asyncSubject.next('hello initial value from AsyncSubject');
  asyncSubject.next('hello 1st value from AsyncSubject'); 
  asyncSubject.subscribe
  asyncSubject.next('hello 2nd value from AsyncSubject'); 
  asyncSubject.complete();
</pre>
<div id="asyncSubject"></div>

<h3>FromEvent</h3>
<button #btnTest>Event Test</button>


<h3>debounceTime</h3>
<input id="dt" #dt type="text"/>
<div>{{dtValue}}</div>
